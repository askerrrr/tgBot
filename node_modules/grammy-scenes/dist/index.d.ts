import * as grammy from 'grammy';
import { Context, Composer, MiddlewareFn, Middleware, MiddlewareObj, LazySessionFlavor } from 'grammy';
import * as ts_essentials from 'ts-essentials';
import { SafeDictionary } from 'ts-essentials';

/**
 * A set of generic enhancements over grammy Composer.
 *
 * These are not specific to grammy-scenes.
 *
 * Unfortunately, they never made it to the official repo.
 */
declare class Composer2<C extends Context> extends Composer<C> {
    /**
     * do() is use() which always calls next()
     */
    do(middleware: MiddlewareFn<C>): this;
    /**
     * Run the provided setup function against the current composer.
     *
     * See https://github.com/grammyjs/grammY/issues/163
     */
    setup(setup: (composer: this) => void): this;
}

declare class StepComposer<C extends ScenesFlavoredContext = ScenesFlavoredContext, S = undefined> extends Composer2<SceneFlavoredContext<C, S>> {
    /** Set payload for ctx.scene.arg in next step */
    arg(arg: any): this;
    /** Call nested scene, then go to the next step. */
    call(sceneId: string, arg?: any): void;
    /** Exit scene. */
    exit(arg?: any): void;
    /** Go to scene step marked with scene.label() */
    goto(label: string, arg?: any): void;
    /** Register middleware for ctx.scenes.notify() calls. */
    onNotify(...middleware: Array<MiddlewareFn<SceneFlavoredContext<C, S>>>): grammy.Composer<SceneFlavoredContext<C, S>>;
}

declare class Scene<C extends ScenesFlavoredContext = ScenesFlavoredContext, S = undefined> {
    readonly id: string;
    _always?: Composer2<SceneFlavoredContext<C, S>>;
    _steps: Array<StepComposer<SceneFlavoredContext<C, S>, S>>;
    _pos_by_label: SafeDictionary<number>;
    _label_by_pos: string[];
    constructor(id: string);
    always(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>): Composer2<SceneFlavoredContext<C, S>>;
    /**
     * Add a scene step.
     */
    step(...middleware: Array<MiddlewareFn<SceneFlavoredContext<C, S>>>): StepComposer<SceneFlavoredContext<C, S>, S>;
    /**
     * Mark a named position in scene to be used by scene.goto()
     */
    label(label: string): this;
    /**
     * Break scene middleware flow.
     * Wait for new updates and pass them to the nested middleware.
     *
     * @example
     * ```ts
     * scene.wait("name").on("message:text", async (ctx) => {
     *   await ctx.reply("...")
     *   if (...) {
     *     ctx.scene.resume()
     *   }
     * })
     * ```
     */
    wait(label: string): StepComposer<SceneFlavoredContext<C, S>, S>;
    /** Set payload for ctx.scene.arg in next step */
    arg(arg: any): StepComposer<SceneFlavoredContext<C, S>, S>;
    /** Call nested scene, then go to the next step. */
    call(sceneId: string, arg?: any): void;
    /** Exit scene. */
    exit(arg?: any): void;
    /** Go to named step. */
    goto(name: string, arg?: any): void;
}

/** injected as ctx.scene */
declare class SceneManager<S = unknown> {
    session: S;
    readonly arg?: any;
    readonly _notify?: boolean;
    constructor({ session, arg, _notify, }: {
        session: S;
        arg?: any;
        _notify?: boolean;
    });
    /** Payload for ctx.scene.arg in next step */
    next_arg: any;
    /** Break scene flow, wait for new updates. */
    _wait(): void;
    _want_wait: boolean;
    /** This middleware must call ctx.scene.resume() to go to the next middleware. */
    _must_resume(): void;
    _want_must_resume: boolean;
    /** Go to the next middleware after this one completes. Used to proceed after wait() */
    resume(): void;
    _want_resume: boolean;
    /** Go to scene step marked with scene.label() */
    goto(label: string, arg?: any): void;
    _want_goto?: {
        label: string;
        arg?: any;
    };
    /**
     * Exit scene.
     *
     * Nested scene will return to outer scene, optionally with argument.
     * */
    exit(arg?: any): void;
    _want_exit?: {
        arg?: any;
    };
    /** Call nested scene, then go to the next step. */
    call(sceneId: string, arg?: any): void;
    _want_call?: {
        scene_id: string;
        arg?: any;
    };
    /** Disregard current scenes stack, switch to a new scene. */
    enter(sceneId: string, arg?: any): void;
    _want_enter?: {
        scene_id: string;
        arg?: any;
    };
    /** Return a token that can be used later for ctx.scenes.notify() */
    createNotifyToken(): string;
    _notify_token?: string;
}
type SceneFlavoredContext<C extends ScenesFlavoredContext, S> = C & {
    readonly scene: SceneManager<S>;
};

/**
 * Top-level collection of scenes.
 */
declare class ScenesComposer<C extends ScenesFlavoredContext> implements MiddlewareObj<C> {
    scenes: SafeDictionary<Scene<C, any>>;
    constructor(...scenes: Scene<C, any>[]);
    scene(scene: Scene<C, any>): void;
    manager(): MiddlewareFn<C>;
    middleware(): MiddlewareFn<C>;
}

/** injected as ctx.scenes */
declare class ScenesManager<C extends ScenesFlavoredContext = ScenesFlavoredContext> {
    readonly ctx: C;
    readonly composer: ScenesComposer<C>;
    constructor(ctx: C, composer: ScenesComposer<C>);
    get scenes(): ts_essentials.SafeDictionary<Scene<C, any>>;
    /** Enter top-level scene */
    enter(sceneId: string, arg?: unknown): Promise<void>;
    /** Abort scenes execution */
    abort(): Promise<void>;
    /** Notify waiting scene */
    notify(token: string, arg?: any): Promise<void>;
    _run_stack(stack: SceneStackFrame[], opts?: SceneRunOpts): Promise<void>;
}
interface SceneRunOpts {
    readonly arg?: any;
    readonly _notify?: boolean;
}

/** grammy session data */
interface ScenesSessionData {
    scenes?: {
        /** Execution stack (inner to outer) */
        stack: SceneStackFrame[];
    };
}
/** @deprecated use ScenesSessionData */
type ScenesSessionFlavor = ScenesSessionData;
/** Scene execution stack frame (stored in session) */
interface SceneStackFrame {
    scene: string;
    /** Should not be stored to session. */
    pos?: number;
    step?: string;
    context?: any;
    token?: string;
}
/** Flavor to grammy context */
type ScenesFlavor = {
    readonly scenes: ScenesManager;
};
/** Base grammy context flavored with scenes. */
type ScenesFlavoredContext<C extends Context = Context> = C & LazySessionFlavor<ScenesSessionData> & ScenesFlavor;

export { Scene, SceneFlavoredContext, SceneManager, SceneRunOpts, SceneStackFrame, ScenesComposer, ScenesFlavor, ScenesFlavoredContext, ScenesManager, ScenesSessionData, ScenesSessionFlavor };

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Scene: () => Scene,
  SceneManager: () => SceneManager,
  ScenesComposer: () => ScenesComposer,
  ScenesManager: () => ScenesManager
});
module.exports = __toCommonJS(src_exports);

// src/composer2.ts
var import_grammy = require("grammy");
var Composer2 = class extends import_grammy.Composer {
  /**
   * do() is use() which always calls next()
   */
  do(middleware) {
    this.use(async (ctx, next) => {
      await middleware(ctx, async () => void 0);
      return next();
    });
    return this;
  }
  /**
   * Run the provided setup function against the current composer.
   *
   * See https://github.com/grammyjs/grammY/issues/163
   */
  setup(setup) {
    setup(this);
    return this;
  }
};

// src/step.ts
var StepComposer = class extends Composer2 {
  /** Set payload for ctx.scene.arg in next step */
  arg(arg) {
    return this.do((ctx) => {
      ctx.scene.next_arg = arg;
    });
  }
  /** Call nested scene, then go to the next step. */
  call(sceneId, arg) {
    this.use((ctx) => ctx.scene.call(sceneId, arg));
  }
  /** Exit scene. */
  exit(arg) {
    this.use((ctx) => ctx.scene.exit(arg));
  }
  /** Go to scene step marked with scene.label() */
  goto(label, arg) {
    this.use((ctx) => ctx.scene.goto(label, arg));
  }
  /** Register middleware for ctx.scenes.notify() calls. */
  onNotify(...middleware) {
    return this.filter((ctx) => ctx.scene?._notify === true, ...middleware);
  }
};

// src/scene.ts
var Scene = class {
  constructor(id) {
    this.id = id;
  }
  _always;
  _steps = [];
  _pos_by_label = {};
  _label_by_pos = [];
  always(...middleware) {
    this._always ??= new Composer2();
    this._always.use(...middleware);
    return this._always;
  }
  /**
   * Add a scene step.
   */
  step(...middleware) {
    const step = new StepComposer(...middleware);
    this._steps.push(step);
    return step;
  }
  /**
   * Mark a named position in scene to be used by scene.goto()
   */
  label(label) {
    const pos = this._steps.length;
    if (this._pos_by_label[label] !== void 0) {
      throw new Error(`Scene ${this.id} already has step ${label}.`);
    }
    if (this._label_by_pos[pos] !== void 0) {
      throw new Error(
        `Scene ${this.id} adding duplicate label ${label} for the same step.`
      );
    }
    this._pos_by_label[label] = pos;
    this._label_by_pos[pos] = label;
    return this;
  }
  /**
   * Break scene middleware flow.
   * Wait for new updates and pass them to the nested middleware.
   *
   * @example
   * ```ts
   * scene.wait("name").on("message:text", async (ctx) => {
   *   await ctx.reply("...")
   *   if (...) {
   *     ctx.scene.resume()
   *   }
   * })
   * ```
   */
  wait(label) {
    this.step((ctx) => {
      ctx.scene._wait();
    });
    if (label) {
      this.label(label);
    }
    return this.step().do((ctx) => {
      ctx.scene._must_resume();
    });
  }
  /** Set payload for ctx.scene.arg in next step */
  arg(arg) {
    return this.step().arg(arg);
  }
  /** Call nested scene, then go to the next step. */
  call(sceneId, arg) {
    this.step().call(sceneId, arg);
  }
  /** Exit scene. */
  exit(arg) {
    this.step().exit(arg);
  }
  /** Go to named step. */
  goto(name, arg) {
    this.step().goto(name, arg);
  }
};

// src/scene-manager.ts
var uuid = __toESM(require("uuid"), 1);
var SceneManager = class {
  session;
  arg;
  _notify;
  constructor({
    session,
    arg,
    _notify
  }) {
    this.session = session;
    this.arg = arg;
    this._notify = _notify;
  }
  /** Payload for ctx.scene.arg in next step */
  next_arg = void 0;
  /** Break scene flow, wait for new updates. */
  _wait() {
    this._want_wait = true;
  }
  _want_wait = false;
  /** This middleware must call ctx.scene.resume() to go to the next middleware. */
  _must_resume() {
    this._want_must_resume = true;
  }
  _want_must_resume = false;
  /** Go to the next middleware after this one completes. Used to proceed after wait() */
  resume() {
    this._want_resume = true;
  }
  _want_resume = false;
  /** Go to scene step marked with scene.label() */
  goto(label, arg) {
    this._want_goto = { label, arg };
  }
  _want_goto;
  /**
   * Exit scene.
   *
   * Nested scene will return to outer scene, optionally with argument.
   * */
  exit(arg) {
    this._want_exit = { arg };
  }
  _want_exit;
  /** Call nested scene, then go to the next step. */
  call(sceneId, arg) {
    this._want_call = { scene_id: sceneId, arg };
  }
  _want_call;
  /** Disregard current scenes stack, switch to a new scene. */
  enter(sceneId, arg) {
    this._want_enter = { scene_id: sceneId, arg };
  }
  _want_enter;
  /** Return a token that can be used later for ctx.scenes.notify() */
  createNotifyToken() {
    return this._notify_token = uuid.v4();
  }
  _notify_token;
};

// src/scenes-composer.ts
var import_ts_essentials = require("ts-essentials");
var ScenesComposer = class {
  scenes = {};
  constructor(...scenes) {
    for (const scene of scenes) {
      this.scene(scene);
    }
  }
  scene(scene) {
    (0, import_ts_essentials.assert)(!this.scenes[scene.id], `Scene ${scene.id} already registered.`);
    this.scenes[scene.id] = scene;
  }
  manager() {
    const mw = (ctx, next) => {
      const writable_ctx = ctx;
      writable_ctx.scenes = new ScenesManager(ctx, this);
      return next();
    };
    return mw;
  }
  middleware() {
    const mw = async (ctx, next) => {
      const session = await ctx.session;
      const stack = session.scenes?.stack;
      if (stack) {
        await ctx.scenes._run_stack(stack);
      } else {
        return next();
      }
    };
    return mw;
  }
};

// src/scenes-manager.ts
var import_debug = __toESM(require("debug"), 1);
var import_grammy2 = require("grammy");
var import_ts_essentials2 = require("ts-essentials");
var debug = (0, import_debug.default)("grammy-scenes");
var ScenesManager = class {
  constructor(ctx, composer) {
    this.ctx = ctx;
    this.composer = composer;
  }
  // Compatibility API
  get scenes() {
    return this.composer.scenes;
  }
  /** Enter top-level scene */
  async enter(sceneId, arg) {
    const scene = this.composer.scenes[sceneId];
    (0, import_ts_essentials2.assert)(scene, `Scene ${sceneId} not found.`);
    await this._run_stack([{ scene: sceneId, pos: 0 }], { arg });
  }
  /** Abort scenes execution */
  async abort() {
    const session = await this.ctx.session;
    session.scenes = void 0;
  }
  /** Notify waiting scene */
  async notify(token, arg) {
    const session = await this.ctx.session;
    const stack = session.scenes?.stack;
    if (stack && token && stack[0]?.token === token) {
      await this._run_stack(stack, { arg, _notify: true });
    }
  }
  async _run_stack(stack, opts) {
    const session = await this.ctx.session;
    session.scenes = void 0;
    while (stack[0]) {
      const frame = stack.shift();
      const scene = this.composer.scenes[frame.scene];
      if (!scene) {
        return;
      }
      const debug_scene = debug.extend(`scene=${scene.id}`);
      const frame_pos = frame.pos ?? (frame.step ? scene._pos_by_label[frame.step] : void 0);
      if (frame_pos === void 0) {
        return;
      }
      let pos = frame_pos;
      let is_first_step = true;
      let scene_session = frame.context;
      let notify_token = frame.token;
      while (true) {
        const debug_step = debug_scene.extend(`pos=${pos}`);
        debug_step("");
        const step = scene._steps[pos];
        if (!step) {
          break;
        }
        const composer = new import_grammy2.Composer();
        if (is_first_step && scene._always) {
          composer.use(scene._always);
        }
        composer.use(step);
        const step_mw = composer.middleware();
        const scene_manager = new SceneManager({
          session: scene_session,
          arg: opts?.arg,
          _notify: opts?._notify
        });
        opts = void 0;
        const inner_ctx = this.ctx;
        inner_ctx.scene = scene_manager;
        try {
          await step_mw(inner_ctx, async () => void 0);
        } finally {
          delete inner_ctx.scene;
        }
        scene_session = scene_manager.session;
        if (scene_manager._notify_token) {
          notify_token = scene_manager._notify_token;
        }
        const get_stack_frame = () => {
          const label = scene._label_by_pos[pos];
          return {
            scene: scene.id,
            pos: label === void 0 ? pos : void 0,
            step: label,
            context: scene_session,
            token: notify_token
          };
        };
        const save_stack = () => {
          const full_stack = [get_stack_frame(), ...stack];
          for (const frame2 of full_stack) {
            if (frame2.pos !== void 0) {
              console.warn(
                `Saving scenes stack with unlabeled steps is discouraged! Please add .label() for step ${frame2.pos} in scene ${frame2.scene}.`
              );
            }
          }
          if (session.scenes) {
            console.warn(
              "Scenes stack has already been saved, probably by calling await ctx.scenes.enter(). Please use ctx.scene.enter() instead."
            );
          }
          session.scenes ??= { stack: full_stack };
        };
        if (scene_manager._want_enter) {
          const { scene_id, arg } = scene_manager._want_enter;
          debug_step(`enter scene ${scene_id}`);
          stack = [{ scene: scene_id, pos: 0 }];
          opts = { arg };
          break;
        } else if (scene_manager._want_exit) {
          debug_step(`exit scene`);
          const { arg } = scene_manager._want_exit;
          opts = { arg };
          break;
        } else if (scene_manager._want_goto) {
          const { label, arg } = scene_manager._want_goto;
          debug_step(`goto step ${label}`);
          const new_pos = scene._pos_by_label[label];
          (0, import_ts_essentials2.assert)(
            new_pos !== void 0,
            `Scene ${scene.id} doesn't have label ${label}.`
          );
          pos = new_pos;
          opts = { arg };
          is_first_step = false;
          continue;
        } else if (scene_manager._want_call) {
          const { scene_id, arg } = scene_manager._want_call;
          debug_step(`call scene ${scene_id}`);
          pos++;
          stack.unshift({ scene: scene_id, pos: 0 }, get_stack_frame());
          opts = { arg };
          break;
        } else if (scene_manager._want_wait) {
          debug_step(`wait`);
          pos++;
          save_stack();
          return;
        } else if (scene_manager._want_must_resume) {
          if (!scene_manager._want_resume) {
            debug_step(`still wait`);
            save_stack();
            return;
          } else {
            notify_token = void 0;
          }
        }
        pos++;
        opts = { arg: scene_manager.next_arg };
        is_first_step = false;
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Scene,
  SceneManager,
  ScenesComposer,
  ScenesManager
});
//# sourceMappingURL=index.cjs.map
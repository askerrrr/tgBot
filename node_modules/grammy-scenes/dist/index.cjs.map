{"version":3,"sources":["../src/index.ts","../src/composer2.ts","../src/step.ts","../src/scene.ts","../src/scene-manager.ts","../src/scenes-composer.ts","../src/scenes-manager.ts"],"sourcesContent":["export * from \"./scene\"\nexport * from \"./scene-manager\"\nexport * from \"./scenes-composer\"\nexport * from \"./scenes-manager\"\nexport * from \"./types\"\n","import { Composer, Context, MiddlewareFn } from \"grammy\"\n\n/**\n * A set of generic enhancements over grammy Composer.\n *\n * These are not specific to grammy-scenes.\n *\n * Unfortunately, they never made it to the official repo.\n */\nexport class Composer2<C extends Context> extends Composer<C> {\n\t/**\n\t * do() is use() which always calls next()\n\t */\n\tdo(middleware: MiddlewareFn<C>) {\n\t\tthis.use(async (ctx, next) => {\n\t\t\tawait middleware(ctx, async () => undefined)\n\t\t\treturn next()\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * Run the provided setup function against the current composer.\n\t *\n\t * See https://github.com/grammyjs/grammY/issues/163\n\t */\n\tsetup(setup: (composer: this) => void) {\n\t\tsetup(this)\n\t\treturn this\n\t}\n}\n","import { MiddlewareFn } from \"grammy\"\n\nimport { SceneFlavoredContext, ScenesFlavoredContext } from \".\"\nimport { Composer2 } from \"./composer2\"\n\nexport class StepComposer<\n\tC extends ScenesFlavoredContext = ScenesFlavoredContext,\n\tS = undefined\n> extends Composer2<SceneFlavoredContext<C, S>> {\n\t/** Set payload for ctx.scene.arg in next step */\n\targ(arg: any) {\n\t\treturn this.do((ctx) => {\n\t\t\tctx.scene.next_arg = arg\n\t\t})\n\t}\n\n\t/** Call nested scene, then go to the next step. */\n\tcall(sceneId: string, arg?: any) {\n\t\tthis.use((ctx) => ctx.scene.call(sceneId, arg))\n\t}\n\n\t/** Exit scene. */\n\texit(arg?: any) {\n\t\tthis.use((ctx) => ctx.scene.exit(arg))\n\t}\n\n\t/** Go to scene step marked with scene.label() */\n\tgoto(label: string, arg?: any) {\n\t\tthis.use((ctx) => ctx.scene.goto(label, arg))\n\t}\n\n\t/** Register middleware for ctx.scenes.notify() calls. */\n\tonNotify(...middleware: Array<MiddlewareFn<SceneFlavoredContext<C, S>>>) {\n\t\treturn this.filter((ctx) => ctx.scene?._notify === true, ...middleware)\n\t}\n}\n","import { Middleware, MiddlewareFn } from \"grammy\"\nimport { SafeDictionary } from \"ts-essentials\"\n\nimport { SceneFlavoredContext, ScenesFlavoredContext } from \".\"\nimport { Composer2 } from \"./composer2\"\nimport { StepComposer } from \"./step\"\n\nexport class Scene<\n\tC extends ScenesFlavoredContext = ScenesFlavoredContext,\n\tS = undefined\n> {\n\t_always?: Composer2<SceneFlavoredContext<C, S>>\n\t_steps: Array<StepComposer<SceneFlavoredContext<C, S>, S>> = []\n\t_pos_by_label: SafeDictionary<number> = {}\n\t_label_by_pos: string[] = []\n\n\tconstructor(public readonly id: string) {}\n\n\talways(...middleware: Array<Middleware<SceneFlavoredContext<C, S>>>) {\n\t\tthis._always ??= new Composer2<SceneFlavoredContext<C, S>>()\n\t\tthis._always.use(...middleware)\n\t\treturn this._always\n\t}\n\n\t/**\n\t * Add a scene step.\n\t */\n\tstep(...middleware: Array<MiddlewareFn<SceneFlavoredContext<C, S>>>) {\n\t\tconst step = new StepComposer<SceneFlavoredContext<C, S>, S>(...middleware)\n\t\tthis._steps.push(step)\n\t\treturn step\n\t}\n\n\t/**\n\t * Mark a named position in scene to be used by scene.goto()\n\t */\n\tlabel(label: string) {\n\t\tconst pos = this._steps.length\n\t\tif (this._pos_by_label[label] !== undefined) {\n\t\t\tthrow new Error(`Scene ${this.id} already has step ${label}.`)\n\t\t}\n\t\tif (this._label_by_pos[pos] !== undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`Scene ${this.id} adding duplicate label ${label} for the same step.`\n\t\t\t)\n\t\t}\n\t\tthis._pos_by_label[label] = pos\n\t\tthis._label_by_pos[pos] = label\n\t\treturn this\n\t}\n\n\t/**\n\t * Break scene middleware flow.\n\t * Wait for new updates and pass them to the nested middleware.\n\t *\n\t * @example\n\t * ```ts\n\t * scene.wait(\"name\").on(\"message:text\", async (ctx) => {\n\t *   await ctx.reply(\"...\")\n\t *   if (...) {\n\t *     ctx.scene.resume()\n\t *   }\n\t * })\n\t * ```\n\t */\n\twait(label: string) {\n\t\tthis.step((ctx) => {\n\t\t\tctx.scene._wait()\n\t\t})\n\t\tif (label) {\n\t\t\tthis.label(label)\n\t\t}\n\t\treturn this.step().do((ctx) => {\n\t\t\tctx.scene._must_resume()\n\t\t})\n\t}\n\n\t/** Set payload for ctx.scene.arg in next step */\n\targ(arg: any) {\n\t\treturn this.step().arg(arg)\n\t}\n\n\t/** Call nested scene, then go to the next step. */\n\tcall(sceneId: string, arg?: any) {\n\t\tthis.step().call(sceneId, arg)\n\t}\n\n\t/** Exit scene. */\n\texit(arg?: any) {\n\t\tthis.step().exit(arg)\n\t}\n\n\t/** Go to named step. */\n\tgoto(name: string, arg?: any) {\n\t\tthis.step().goto(name, arg)\n\t}\n}\n","import * as uuid from \"uuid\"\n\nimport { ScenesFlavoredContext } from \".\"\n\n/** injected as ctx.scene */\nexport class SceneManager<S = unknown> {\n\tsession: S\n\treadonly arg?: any\n\treadonly _notify?: boolean\n\n\tconstructor({\n\t\tsession,\n\t\targ,\n\t\t_notify,\n\t}: {\n\t\tsession: S\n\t\targ?: any\n\t\t_notify?: boolean\n\t}) {\n\t\tthis.session = session as S\n\t\tthis.arg = arg\n\t\tthis._notify = _notify\n\t}\n\n\t/** Payload for ctx.scene.arg in next step */\n\tnext_arg: any = undefined\n\n\t/** Break scene flow, wait for new updates. */\n\t_wait() {\n\t\tthis._want_wait = true\n\t}\n\t_want_wait = false\n\n\t/** This middleware must call ctx.scene.resume() to go to the next middleware. */\n\t_must_resume() {\n\t\tthis._want_must_resume = true\n\t}\n\t_want_must_resume = false\n\n\t/** Go to the next middleware after this one completes. Used to proceed after wait() */\n\tresume() {\n\t\tthis._want_resume = true\n\t}\n\t_want_resume = false\n\n\t/** Go to scene step marked with scene.label() */\n\tgoto(label: string, arg?: any) {\n\t\tthis._want_goto = { label, arg }\n\t}\n\t_want_goto?: { label: string; arg?: any }\n\n\t/**\n\t * Exit scene.\n\t *\n\t * Nested scene will return to outer scene, optionally with argument.\n\t * */\n\texit(arg?: any) {\n\t\tthis._want_exit = { arg }\n\t}\n\t_want_exit?: { arg?: any }\n\n\t/** Call nested scene, then go to the next step. */\n\tcall(sceneId: string, arg?: any) {\n\t\tthis._want_call = { scene_id: sceneId, arg }\n\t}\n\t_want_call?: { scene_id: string; arg?: any }\n\n\t/** Disregard current scenes stack, switch to a new scene. */\n\tenter(sceneId: string, arg?: any) {\n\t\tthis._want_enter = { scene_id: sceneId, arg }\n\t}\n\t_want_enter?: { scene_id: string; arg?: any }\n\n\t/** Return a token that can be used later for ctx.scenes.notify() */\n\tcreateNotifyToken() {\n\t\treturn (this._notify_token = uuid.v4())\n\t}\n\t_notify_token?: string\n}\n\nexport type SceneFlavoredContext<C extends ScenesFlavoredContext, S> = C & {\n\treadonly scene: SceneManager<S>\n}\n","import { MiddlewareFn, MiddlewareObj } from \"grammy\"\nimport { assert, SafeDictionary } from \"ts-essentials\"\n\nimport { Scene, ScenesFlavoredContext, ScenesManager } from \".\"\n\n/**\n * Top-level collection of scenes.\n */\nexport class ScenesComposer<C extends ScenesFlavoredContext>\n\timplements MiddlewareObj<C>\n{\n\tscenes: SafeDictionary<Scene<C, any>> = {}\n\n\tconstructor(...scenes: Scene<C, any>[]) {\n\t\tfor (const scene of scenes) {\n\t\t\tthis.scene(scene)\n\t\t}\n\t}\n\n\tscene(scene: Scene<C, any>) {\n\t\tassert(!this.scenes[scene.id], `Scene ${scene.id} already registered.`)\n\t\tthis.scenes[scene.id] = scene\n\t}\n\n\tmanager(): MiddlewareFn<C> {\n\t\tconst mw: MiddlewareFn<C> = (ctx, next) => {\n\t\t\tconst writable_ctx = ctx as any\n\t\t\twritable_ctx.scenes = new ScenesManager<C>(ctx, this)\n\t\t\treturn next()\n\t\t}\n\t\treturn mw\n\t}\n\n\tmiddleware() {\n\t\tconst mw: MiddlewareFn<C> = async (ctx, next) => {\n\t\t\tconst session = await ctx.session\n\t\t\tconst stack = session.scenes?.stack\n\t\t\tif (stack) {\n\t\t\t\tawait ctx.scenes._run_stack(stack)\n\t\t\t} else {\n\t\t\t\treturn next()\n\t\t\t}\n\t\t}\n\t\treturn mw\n\t}\n}\n","import Debug from \"debug\"\nimport { Composer } from \"grammy\"\nimport { assert } from \"ts-essentials\"\n\nimport {\n\tSceneFlavoredContext,\n\tSceneManager,\n\tScenesComposer,\n\tScenesFlavoredContext,\n\tSceneStackFrame,\n} from \".\"\n\nconst debug = Debug(\"grammy-scenes\")\n\n/** injected as ctx.scenes */\nexport class ScenesManager<\n\t// This is a public type, so we provide defaults.\n\tC extends ScenesFlavoredContext = ScenesFlavoredContext\n> {\n\tconstructor(\n\t\tpublic readonly ctx: C,\n\t\tpublic readonly composer: ScenesComposer<C>\n\t) {}\n\n\t// Compatibility API\n\tget scenes() {\n\t\treturn this.composer.scenes\n\t}\n\n\t/** Enter top-level scene */\n\tasync enter(sceneId: string, arg?: unknown) {\n\t\tconst scene = this.composer.scenes[sceneId]\n\t\tassert(scene, `Scene ${sceneId} not found.`)\n\t\tawait this._run_stack([{ scene: sceneId, pos: 0 }], { arg })\n\t}\n\n\t/** Abort scenes execution */\n\tasync abort() {\n\t\tconst session = await this.ctx.session\n\t\tsession.scenes = undefined\n\t}\n\n\t/** Notify waiting scene */\n\tasync notify(token: string, arg?: any) {\n\t\tconst session = await this.ctx.session\n\t\tconst stack = session.scenes?.stack\n\t\tif (stack && token && stack[0]?.token === token) {\n\t\t\tawait this._run_stack(stack, { arg, _notify: true })\n\t\t}\n\t}\n\n\tasync _run_stack(stack: SceneStackFrame[], opts?: SceneRunOpts) {\n\t\t// Delete the stack from the session.\n\t\t// Re-save it explicitly if ctx.scene._wait() was called.\n\t\tconst session = await this.ctx.session\n\t\tsession.scenes = undefined\n\n\t\twhile (stack[0]) {\n\t\t\tconst frame = stack.shift()!\n\t\t\tconst scene = this.composer.scenes[frame.scene]\n\t\t\tif (!scene) {\n\t\t\t\t// Invalid session data - abort.\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst debug_scene = debug.extend(`scene=${scene.id}`)\n\n\t\t\tconst frame_pos =\n\t\t\t\tframe.pos ?? (frame.step ? scene._pos_by_label[frame.step] : undefined)\n\t\t\tif (frame_pos === undefined) {\n\t\t\t\t// Invalid session data - abort.\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlet pos = frame_pos\n\t\t\tlet is_first_step = true\n\t\t\tlet scene_session = frame.context\n\t\t\tlet notify_token = frame.token\n\n\t\t\twhile (true) {\n\t\t\t\tconst debug_step = debug_scene.extend(`pos=${pos}`)\n\t\t\t\tdebug_step(\"\")\n\n\t\t\t\tconst step = scene._steps[pos]\n\t\t\t\tif (!step) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tconst composer = new Composer<SceneFlavoredContext<C, any>>()\n\t\t\t\tif (is_first_step && scene._always) {\n\t\t\t\t\tcomposer.use(scene._always)\n\t\t\t\t}\n\t\t\t\tcomposer.use(step)\n\t\t\t\tconst step_mw = composer.middleware()\n\n\t\t\t\tconst scene_manager = new SceneManager({\n\t\t\t\t\tsession: scene_session,\n\t\t\t\t\targ: opts?.arg,\n\t\t\t\t\t_notify: opts?._notify,\n\t\t\t\t})\n\t\t\t\topts = undefined\n\n\t\t\t\tconst inner_ctx = this.ctx as any\n\t\t\t\tinner_ctx.scene = scene_manager\n\t\t\t\ttry {\n\t\t\t\t\tawait step_mw(inner_ctx, async () => undefined)\n\t\t\t\t} finally {\n\t\t\t\t\tdelete inner_ctx.scene\n\t\t\t\t}\n\t\t\t\tscene_session = scene_manager.session\n\t\t\t\tif (scene_manager._notify_token) {\n\t\t\t\t\tnotify_token = scene_manager._notify_token\n\t\t\t\t}\n\n\t\t\t\tconst get_stack_frame = (): SceneStackFrame => {\n\t\t\t\t\tconst label = scene._label_by_pos[pos]\n\t\t\t\t\treturn {\n\t\t\t\t\t\tscene: scene.id,\n\t\t\t\t\t\tpos: label === undefined ? pos : undefined,\n\t\t\t\t\t\tstep: label,\n\t\t\t\t\t\tcontext: scene_session,\n\t\t\t\t\t\ttoken: notify_token,\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst save_stack = () => {\n\t\t\t\t\tconst full_stack = [get_stack_frame(), ...stack]\n\t\t\t\t\tfor (const frame of full_stack) {\n\t\t\t\t\t\tif (frame.pos !== undefined) {\n\t\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\t`Saving scenes stack with unlabeled steps is discouraged! Please add .label() for step ${frame.pos} in scene ${frame.scene}.`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (session.scenes) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"Scenes stack has already been saved, probably by calling await ctx.scenes.enter(). Please use ctx.scene.enter() instead.\"\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tsession.scenes ??= { stack: full_stack }\n\t\t\t\t}\n\n\t\t\t\tif (scene_manager._want_enter) {\n\t\t\t\t\t// Replace stack with new scene.\n\t\t\t\t\tconst { scene_id, arg } = scene_manager._want_enter\n\t\t\t\t\tdebug_step(`enter scene ${scene_id}`)\n\t\t\t\t\tstack = [{ scene: scene_id, pos: 0 }]\n\t\t\t\t\topts = { arg }\n\t\t\t\t\tbreak\n\t\t\t\t} else if (scene_manager._want_exit) {\n\t\t\t\t\t// Exit current scene.\n\t\t\t\t\tdebug_step(`exit scene`)\n\t\t\t\t\tconst { arg } = scene_manager._want_exit\n\t\t\t\t\topts = { arg }\n\t\t\t\t\tbreak\n\t\t\t\t} else if (scene_manager._want_goto) {\n\t\t\t\t\t// Goto step inside current scene.\n\t\t\t\t\tconst { label, arg } = scene_manager._want_goto\n\t\t\t\t\tdebug_step(`goto step ${label}`)\n\t\t\t\t\tconst new_pos = scene._pos_by_label[label]\n\t\t\t\t\tassert(\n\t\t\t\t\t\tnew_pos !== undefined,\n\t\t\t\t\t\t`Scene ${scene.id} doesn't have label ${label}.`\n\t\t\t\t\t)\n\t\t\t\t\tpos = new_pos\n\t\t\t\t\topts = { arg }\n\t\t\t\t\tis_first_step = false\n\t\t\t\t\tcontinue\n\t\t\t\t} else if (scene_manager._want_call) {\n\t\t\t\t\t// Call inner scene.\n\t\t\t\t\tconst { scene_id, arg } = scene_manager._want_call\n\t\t\t\t\tdebug_step(`call scene ${scene_id}`)\n\t\t\t\t\tpos++\n\t\t\t\t\tstack.unshift({ scene: scene_id, pos: 0 }, get_stack_frame())\n\t\t\t\t\topts = { arg }\n\t\t\t\t\tbreak\n\t\t\t\t} else if (scene_manager._want_wait) {\n\t\t\t\t\t// wait() called - exit and save next step.\n\t\t\t\t\tdebug_step(`wait`)\n\t\t\t\t\tpos++\n\t\t\t\t\tsave_stack()\n\t\t\t\t\treturn\n\t\t\t\t} else if (scene_manager._want_must_resume) {\n\t\t\t\t\t// Inside wait() handler.\n\t\t\t\t\tif (!scene_manager._want_resume) {\n\t\t\t\t\t\t// resume() not called - exit and save current step.\n\t\t\t\t\t\tdebug_step(`still wait`)\n\t\t\t\t\t\tsave_stack()\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Invalidate notify token. It's supposed to only work for the nearest wait/notify/resume.\n\t\t\t\t\t\tnotify_token = undefined\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos++\n\t\t\t\topts = { arg: scene_manager.next_arg }\n\t\t\t\tis_first_step = false\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport interface SceneRunOpts {\n\treadonly arg?: any\n\treadonly _notify?: boolean\n}\n"],"mappings":"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","names":["import_grammy","import_ts_essentials","Debug","frame"]}